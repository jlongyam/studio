<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>How-node.js-is-integrated-with-chromium.html</title>
  <meta name="generator" content="Haroopad 0.13.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="../asset/clearness-dark.css" rel="stylesheet">
</head>
<body class="markdown clearness-dark">
<h2 id="overview"><a name="overview" href="#overview"></a>Overview</h2><p>We keep the modification minimal on both Node and Chromium. Only 2 things are done: main loop integration and context bridging.</p><p>Both <code>node.js</code> and <code>Chromium</code> have their main loops. So it would take some efforts to make it run in <code>Chromium</code>. One of the founding feature of node-webkit is to call Node functions <strong>directly</strong> from DOM, so we integrate them into the same thread. That requires the integration of the main loop of Node and the one from Chromium Render process.</p><p>In order to make the objects from Node and DOM to refer to each other, Node is made to use the same V8 engine instance as the one in Chromium. The objects from the 2 worlds are in 2 <code>contexts</code> respectively, to keep their namespace clean.</p><h2 id="main-loop-integration"><a name="main-loop-integration" href="#main-loop-integration"></a>Main Loop Integration</h2><p><code>Chromium</code> internally use class <code>MessageLoop</code> and <code>MessagePump</code> to support its events loop, since <code>node</code> uses <code>libuv</code> to support its events loop, we need to implement a new <code>MessagePump</code> which uses <code>libuv</code> as its underlying events library. The new type of Message Pump is used only in the render process, where the WebKit engine resides.</p><p>See <code>base/message_pump_uv.cc</code>, <code>base/message_pump_uv.cc</code>, <code>base/message_loop.cc</code> and <code>base/message_loop.h</code> to understand our work.</p><p>On Mac things are a lot different, see <code>base/message_pump_mac.h</code> and <code>base/message_pump_mac.mm</code>.</p><h2 id="context-bridging:-insert-node's-symbols-into-webkit"><a name="context-bridging:-insert-node's-symbols-into-webkit" href="#context-bridging:-insert-node's-symbols-into-webkit"></a>Context bridging: Insert nodeâ€™s symbols into webkit</h2><p>This is the most important and trickiest part of <code>node-webkit</code>, first we initialize a context for <code>node</code>, and make <code>node</code> setup all its stuff under it, see <code>content/renderer/renderer_main.cc</code>, then when WebKit has installed DOM into its context, we move everything from <code>node</code> to <code>WebKit</code>, see <code>third_party/WebKit/Source/WebCore/bindings/v8/V8DOMWindowShell.cpp</code> in line 346.</p><h2 id="make-node-start-with-render-process"><a name="make-node-start-with-render-process" href="#make-node-start-with-render-process"></a>Make Node start with render process</h2><p>Though <code>node</code> has a <code>Start</code> function that setups everything, it will redirect everything into its own message loop, so we split the <code>Start</code> function into several parts, see <code>third_party/node/src/node.cc</code>.</p><p>And since <code>node</code> itself expects to execute a script file, there are many logics that deal with script execution in <code>third_party/node/src/node.js</code>, we heavily modified that part and used some tricks to make its module system run under <code>node-webkit</code>.</p><p>Another modification resided under <code>third_party/WebKit/Source/WebCore/bindings/v8/V8DOMWindowShell.cpp</code> in line 363, we inserted some script after WebKit is initialized, so <code>node</code> can get a right <code>pathname</code> and <code>filename</code> which is vital to <code>require</code> function.</p>


</body>
</html>
